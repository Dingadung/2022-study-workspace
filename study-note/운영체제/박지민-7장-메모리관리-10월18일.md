박지민-7장-메모리관리-10월18일
# 1. 주소 바인딩
## 논리적 주소(logical address)<br>가상 주소(virtual address)
>프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성되는데 이때의 주소를 말한다.

CPU는 이와 같이 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다.
논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.

## 물리적 주소(physical address)
>논리적 주소와 달리 실제로 올라가는 위치를 말한다.

보통 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 영역에는 사용자 프로세스들이 올라간다.

## 주소 바인딩(address binding)
>프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업

주소 바인딩의 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류할 수 있다.
- 컴파일 타임 바인딩 (compile time binding)
- 로드 타임 바인딩 (load time binding)
- 실시간 바인딩 (execution time binding 또는 run time binding)

### 컴파일 타임 바인딩 (compile time binding)
>먼저 물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식

이 바인딩 기법은 컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 결정한다.

프로그램이 절대주소로 적재된다는 뜻에서 이와 같은 주소 바인딩 방식을 **절대코드(absolite code)**를 생성하는 바인딩 방식이라고도 한다.

비현실적인 방식이라 잘 사용하지 않는다.

### 로드 타임 바인딩 (load time binding)
>로더(loader)의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다.

#### 로더
>사용자 프로그래을 메모리에 적재시키는 프로그램

로드타임바인딩은 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식이다.

### 실시간 바인딩 (execution time binding 또는 run time binding)
>프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식이다.

이 방식에서는 CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검해야 한다.

#### MMU(Memory Management Unit: 메모리 관리 유닛)
실시간 바인딩 방식이 가능하기 위해서는 기준 레지스터와 한계 레지스터를 포함해 MMU라는 하드웨어적인 지원이 뒷받침 되어야 한다.
>MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.

#### MMU 기법(MMU sheme)
주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.

이때, 기준 레지스터는 재배치 레지스터(relocation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.

#### 한계 레지스터(limit register)
>프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용되며, 현재 CPU에서 수행중인프로세스의 논리적 주소이 최댓값, 즉 그 프로세스의 크기를 담고 있다.

---
# 2. 메모리 관리와 관련된 용어
## (1) 동적 로딩(dynamic loading)
>여러 프로그램이 동시에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나이다.

동적로딩에서는 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 메모리를 좀 더 효율적으로 사용하기 위해 해당 부분이 불릴 때 그 부분만을 메모리에 적재하는 방식을 사용한다.
⇒ 프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재하는 것

동적로딩 기법은 사용되지도 않을 만은 양의 코드가 메모리에 올라가는 것을 막아 메모리를 좀 더 효율적으로 사용할 수 있도록 한다.

## (2) 동적 연결
### 연결(linking)
>프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과, 이미 컴파일된 라이브러리 파일(library file)들을 묶어 하나의 실행파일을 생성하는 과정

### 동적 연결(dynamic linking)
>컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법

동적연결에서는 라이브러리가 실행 시점에 연결되어 실행파일에 라이브러리 코드가 포함되지 않으며, 
프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다.

⇒ 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둔다.

### 정적 연결(static linking)
>프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성된다.

## (3) 중첩(overlays)
>프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법

### 중첩과 동적로딩의 차이
- `동적로딩`
메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도
- `중첩`
단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 용도

## (4) 스와핑(swapping)
>메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓은 것을 말한다.

스왑영역은 백킹스토어(backing store)라고도 부른다.

### 스왑 인(swap in)
>스와핑에서 일어나는 작업의 방향에 따라 디스크에서 메모리로 올리는 작업

### 스왑 아웃(swap out)
>메모리에서 디스크로 내리는 작업

### 스와핑이 일어나는 과정
스와퍼(swapper)라고 불리는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정
→ 스왑 아웃 대상으로 선정된 프로세스에 대해서는 현재 메모리에 올라가 있는 주소 공간의 내용을 통째로 디스크 스왑 영역에 스왑 아웃

### 스와핑의 가장 중요한 역할
메모리에 존재하는 프로세스의 수를 조절하는 것
⇒ 스와핑을 통해 다중 프로그래밍의 정도(degree of multiprogramming)를 조절할 수 있다.

---
# 3. 물리적 메모리의 할당 방식
물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉘어 사용된다.
- 운영체제 상주 영역
- 사용자 프로세스 영역

## 운영체제 상주 영역
>인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, 운영체제 커널이 이곳에 위치하게 된다.

## 사용자 프로세스 영역
>물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행된다.

사용자 프로세스 영역의 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 두 가지 방식으로 나누어 볼 수 있다.
- 연속할당방식(contiguous allocation)
- 불연속할당방식(noncontiguous allocation)

### 연속할당방식(contiguous allocation)
>각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식

물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.

연속할당방식은 분할을 관리하는 방식에 따라 두 가지 방식으로 다시 나눌 수 있다.
- 고정분할방식(fixed partition allocation)
- 가변분할방식(variable partition allocation)

#### 고정분할방식(fixed partition allocation)
물리적 메모리를 고정된 크기의 분할로 미리 나누어두는 방식

#### 가변분할방식(variable partition allocation)
분할을 미리 나누어 놓지 않은 채 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식

### 불연속할당방식(noncontiguous allocation)
>하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식

불연속할당에는 세 가지 기법이 있다.
- 페이징(paging) 기법
- 세그멘테이션(segmentation) 기법
- 페이지드 세그멘테이션(paged segmentation) 기법

#### 페이징(paging) 기법
각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 기법

#### 세그멘테이션(segmentation) 기법
프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재하는 방식

#### 페이지드 세그멘테이션(paged segmentation) 기법
세그먼트 하나를 다수의 페이지로 구성하는 방식

---
# 4. 페이징 기법
>프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식

물리적 메모리를 페이지와 동일한 크기의 `프레임(frame)` 으로 미리 나누어 둔다.

모든 프로세스가 각각의 주소 변환을 위한 `페이지 테이블(page table)`을 가진다.

외부조각 문제가 발생하지 않지만, 제일 마지막에 위치한 페이지에서는 내부조각이 발생할 가능성이 있다.

## (1) 주소 변환 기법
>CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환(address translation)에 사용한다.

### 페이지 번호
각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 `인덱스(index)` 로 사용되고,
해당 인덱스의 `항목(entry)` 에는 그 페이지의 물리적 메모리상의 `기준 주소(base address)` , 즉 시작 위치가 저장된다.

### 페이지 오프셋
하나의 페이지 내에서 `변위(displacement)` 를 알려준다.

## (2) 페이지 테이블의 구현
>페이징 기법에서 주소 변환을 하기 위한 자료구조로, 물리적 메모리에 위치하게 된다.

현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다.
- 페이지 테이블 기준 레지스터(page-table base register)
- 페이지 테이블 길이 레지스터(page-table length register)

### 페이지 테이블 기준 레지스터(page-table base register)
메모리 내에서의 페이지 테이블의 시작 위치를 가르킨다.

### 페이지 테이블 길이 레지스터(page-table length register)
페이지 테이블의 크기를 보관한다.

### TLB
페이징 기법에서의 메모리 접근 연산은 두 번의 메모리 접근, 오버헤드가 뒤따른다.
- 주소 변환을 위해 페이지 테이블에 접근하는 것
- 변환된 주소에서 실제 데이터에 접근하는 것

이러한 오버헤드를 줄이기 위해 `TLB(Translation Look-aside Buffer` 라고 불리는 고속의 주소변환용 하드웨어 캐시가 사용된다.

`TLB` 의 구현에는 일반적으로 병렬 탐색이 가능한 `연관 레지스터(associative register)` 를 사용한다.

#### EAT
`연관 레지스터` 를 사용할 때 평균적인 메모리 접근시간(Effective Access Time: EAT)
`EAT` = (1 + ε)α + (2 + ε)(1 - α)

## (3) 계층적 페이징
페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 `2단계 페이징(two-level paging) 기법` 을 사용한다.

`2단계 페이징(two-level paging) 기법` 에서는 주소 변환을 위해 두 단계에 걸친 페이지 테이블을 사용한다.

1. 외부 페이지 테이블(outer page table)
2. 내부 페이지 테이블(inner page table)

프로세스의 논리적 주소를 두 종류의 페이지 번호(P1, P2)와 페이지 오프셋(d)로 구분한다.

## (4) 역페이지 테이블(inverted page table)
>물리적 메모리의 페이지 프로임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식

페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담고 있는다.

역페이지 테이블을 물리적 주소로부터 논리적 주소를 얻기 수월한 구조로 되어 있다.

## (5) 공유 페이지
### 공유 코드(shared code)
>메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드

재진입 가능 코드 또는 순수 코드라고도 불린다.

`읽기전용(read-only)` 의 특성을 가지고 있다.

### 공유 페이지(shared page)
>공유 코드를 담고 있는 페이지

공유페이지는 여러 프로세스에 의해 공유되는 페이지이므로 물리적 메모리 하나만 적재되어 메모리를 좀 더 효율적으로 사용할 수 있게 한다.

### 사유 페이지(private page)
>공유 페이지와 대비되는 개념으로, 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지를 말한다.

## (6) 메모리 보호
페이지 테이블의 각 항목에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 두 비트를 둔다.
- 보호비트(protection bit)
- 유효-무효 비트(valid-invalid bit)

### 보호비트(protection bit)
각 페이지에 대해 읽기-쓰기/읽기전용 등의 접근 권한을 설정하는데 사용된다.

### 유효-무효 비트(valid-invalid bit)
해당 페이지의 내용이 유효한지에 대한 내용을 담고 있다.

---
# 5. 세그먼테이션
## 세그먼테이션(segmentation) 기법
>지금부터는 프로세스의 주소 공간을 의미 단위의 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법

## 세그먼트
>주소 공간을 기능 단위 또는 의미 단위로 나눈 것을 의미한다.

일반적으로 기능 단위로 세그먼트를 정의한다.

세그먼트는 논리적인 단위(logical unit)로 나눈 것이기 때문에 크기가 균일하지 않다.

## 세그먼트 테이블
세그먼트 기법에서는 주소 변환을 위해 세그먼트 테이블을 사용한다.
세그먼트 테이블을 두가지 항목을 가진다.
- 기준점(base)
- 한계점(limit)


세그먼테이션 기법에서는 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확인한다.

1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인가?
2. 논리적 주소의 오프셋값이 그 세그먼트의 길이보다 작은 값인가?

---
# 6. 페이지드 세그멘테이션
>페이징 기법과 세그먼테이션 기법의 장점만 취하는 주소 변환 기법

세그먼테이션 기법과 마찬가지로 프로그램을 의미 단위의 세그먼트로 나눈다.
물리적 메모리에 적재하는 단위는 페이지 단위로 한다.

하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부조각의 문제점을 해결하며, 동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소한다.

주소변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용한다.